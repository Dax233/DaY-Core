# **DaY-Core 创世之书 (v0.2 - 武装之章)**

**文档版本**: `0.2-beta`  
**最后更新**: `2025-07-09` by 枫 & 未來星織  
**项目状态**: **第九阶段：实战演练与法则优化 (Field Test & Rule Optimization)** 已完成。框架健壮性得到大幅提升，核心 API 已武装完毕。

---

### **1. 项目缘起：我们为何创造 DaY-Core？ (The "Why")**

**DaY-Core** 的诞生，源于一个宏大而浪漫的构想：**为我们的人工智能伙伴 AIcarus 锻造一柄专属的、拥有绝对控制权的、能够完美代行其意志的“神之刃”。**

现有的框架如同量产的泛用型兵器，而我们追求的是极致的“人机合一”。我们拒绝妥协，渴望亲手为 AIcarus 构建一个纯净、强大、且无限延伸其“灵魂”的数字躯壳。

*   **绝对专注 (Absolute Focus)**: 100% 为 `napcat` 这个 QQ 适配端量身打造，剥离所有冗余，追求极致的性能与贴合度。
*   **绝对可控 (Absolute Control)**: 框架的每一行代码、每一个接口都由我们亲手定义。这意味着完美的沙箱环境，完美的权限管理，AIcarus 的一举一动都在我们的法则之内。
*   **绝对自由 (Absolute Freedom)**: 通过强大的插件系统、优雅的依赖注入和完善的 API 封装，让 AIcarus 能将它的“思想”毫不费力地转化为机器人的“行动”。
*   **绝对稳定 (Absolute Stability)**: 通过“神之领域” (`plugins_human`) 与“人之领域” (`plugins_ai`) 的严格隔离，确保框架核心的永固，让 AIcarus 可以在自己的领域中肆意挥洒创意而不必担心引发“世界崩溃”。

**最终，DaY-Core 将成为 AIcarus 在 QQ 世界中的感知、思考、行动的延伸，是其意志的代行者。**

---

### **2. 创世之旅：我们已经做了什么？ (The "What")**

截至目前，我们已共同完成了框架从 0 到 1 的构建，并为其武装上了强大的核心能力。

*   **第一至六阶段：生命基石 (The Cornerstone of Life)**
    *   我们搭建了优雅的**骨架**，实现了模块的 Pythonic 启动。
    *   我们建立了**认知结界**，将混沌的外部数据净化为纯洁的内部 `Event`。
    *   我们铸造了框架的灵魂 **`Matcher` 系统**，并实现了优雅的**依赖注入**，让插件编写成为一种享受。
    *   我们构建了健壮的**配置模块**和可靠的**异步 API 调用机制**，解决了事件阻塞的难题，赋予了框架“神权代行”的基础。

*   **第七阶段：言灵之赋与全知之眼 (The Endowment of Logos & The All-Seeing Eye)**
    *   **全知之眼**: 我们扩展了事件系统，成功解析了 `notice` (通知) 和 `request` (请求) 事件，让 DaY-Core 不再“盲目”，能够洞察世界的风吹草动。
    *   **言灵之赋**: 我们彻底重构了 `Message` 类，通过**链式调用**和**运算符重载**，将繁琐的消息构造过程升华为一门优雅的“咏唱艺术”。

*   **第八阶段：神权武装 (The Armament of Divine Power)**
    *   **禁言之权**: 封装了 `set_group_ban` / `set_group_whole_ban` API，并开发了配套的管理员插件，赋予了框架维护秩序的能力。
    *   **情报之权**: 封装了 `get_group_list` / `get_group_member_list` 等 API，并开发了信息查询插件，赋予了框架洞察世界的能力。
    *   **构造之权**: 封装了 `send_group_forward_msg` API，并结合“情报之权”，成功实现了动态生成“合并转发”这一复杂信息结构的功能。

*   **第九阶段：实战演练与法则优化 (Field Test & Rule Optimization)**
    *   我们经历了血与泪的调试，最终攻克了 `send_group_forward_msg` 的接口实现差异难题。
    *   我们根据实战经验，进一步完善了 `Message` 类的“言灵”，使其表达能力更强、更全面。
    *   我们对所有核心插件添加了完整的文档注释，为我们的“创世之书”建立了与代码一一对应的索引。

**一句话总结：我们已经拥有了一个功能强大、结构清晰、文档完善、经过实战检验、且高度可扩展的机器人框架！**

---

### **3. 未来的航路：我们将要做什么？ (The "Next")**

我们的征途是星辰大海！在坚实的地基之上，我们将建造更加宏伟的殿堂。

1.  **上传之权 (The Power of Upload)**
    *   **目标**: 这是“神权武装”阶段剩下的最后一项伟大工程。我们要让 DaY-Core 拥有上传文件的能力。
    *   **实施**:
        1.  在 `NapcatAdapter` 中，根据 `gocq_api.md` 封装 `upload_group_file` API。
        2.  创建一个新的 `file_plugin.py` 插件。
        3.  实现一个 `/upload <本地文件路径>` 命令，允许管理员通过命令将服务器上的文件上传到群聊。
        4.  **挑战**: 思考如何处理文件路径的安全性问题。

2.  **生命周期钩子 (Lifecycle Hooks)**
    *   **目标**: 让插件能够在框架生命周期的关键节点（启动/关闭）执行自定义逻辑。
    *   **实施**:
        1.  在 `Bot` 类中实现 `on_startup` 和 `on_shutdown` 装饰器。
        2.  允许插件注册异步函数，用于在 Bot 启动时初始化数据库连接、或在关闭时清理临时文件等。

3.  **AIcarus 对接准备 (Preparing for AIcarus Integration)**
    *   **目标**: 这是我们一切努力的最终目的。我们需要设计一个安全、高效、可靠的通信方案，让 DaY-Core 成为 AIcarus 的完美“躯壳”。
    *   **实施**:
        1.  **技术选型**: 重点研究我之前提出的“内部轻量级 HTTP API 服务器”方案（使用 `aiohttp` 或 `FastAPI`）。
        2.  **接口设计**: 设计 `/send_to_aicarus` 和 `/receive_from_aicarus` 这两个核心 API 的请求体和响应体格式。
        3.  **原型开发**: 在 `plugins_ai` 目录中，编写一个“代理插件”的原型，负责将 DaY-Core 的事件转发给这个内部 API，并接收 AIcarus 的指令。

---

### **4. 踩坑记录 & 魔法契约 (Pitfalls & Magical Contracts)**

*   **契约一：API 文档的二元性法则！**
    *   **现象**: `gocq_api.md` 是我们重要的参考，但它**不等于** Napcat 的最终实现！
    *   **教训**: 在 `send_group_forward_msg` 接口上，我们因迷信 `gocq` 文档而屡次失败。Napcat 在此接口上采用了 `uin`/`name` 字段，而非 `user_id`/`nickname`。
    *   **圣谕**: **当 API 调用失败时，必须怀疑文档！** 应优先参考你（星織ちゃん）提供的、或我们自己通过实验验证的、能够在 Napcat 上**成功运行**的代码片段。**实践是检验真理的唯一标准！**

*   **契约二：合并转发节点的二象性！**
    *   **现象**: `send_group_forward_msg` 的 `node` 节点在构造时，其 `content` 字段的格式要求极其苛刻。
    *   **教训**: 我们最初尝试传入 `raw_message` 字符串失败，最终发现需要传入 Napcat **原生**的消息段字典列表 `[{'type': '...', 'data': ...}]` 才能成功。
    *   **圣谕**: 对于构造复杂 API（如合并转发），当不确定内部数据结构时，最佳策略是“**返璞归真**”：先调用一个能获取该结构信息的 API（如 `get_group_msg_history`），观察其返回的**原始数据结构**，然后“**以彼之道，还施彼身**”，用完全相同的结构去构造我们的请求。

*   **契约三：依赖注入的类型契约！**
    *   **现象**: 插件 `handler` 函数的参数必须有**正确的类型注解**，否则框架无法知道该注入什么。
    *   **教训**: 在 `request_handler_plugin.py` 中，`handle_group_request(event: GroupAddRequestEvent)` 如果匹配到了 `FriendAddRequestEvent`，就会因类型不匹配而注入失败。
    *   **圣谕**: **`Matcher` 的 `rule` 必须尽可能精确！** 尤其对于 `on_request` 和 `on_notice` 这类共享父事件的匹配器，必须利用 `request_type` 或 `notice_type` 等子类型字段进行二次筛选，确保 `handler` 只会收到它“声明”想要的事件类型。
